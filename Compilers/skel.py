'''
For the maintainer:

The contents of this module constitutes the  components for managing a 
stack of symbol tables for use with lexical / syntax analysis and code
generation.

Symbol Table Entries can be expanded or altered by changing the 
    definition of the STEntry namedtuple.  Minimally, it must contain
    'lexeme' and 'tokval'

A Symbol Table is a namedtuple (name, tab) where
    name is a string and
    tab is an OrderedDict that contains Symbol Table Entries 
          hashed on lexeme

The Symbol Table Stack is implemented as a subclassed list of Symbol Tables,
    augmented with appropriate methods for managing the tables
'''


class STSt(list):
    '''STSt() -> empty symbol table stack

    The STSt is a stack for the maintenance of symbol tables
    '''
    def st_find(self, lexeme):
        '''Search the stack top-down for first occurance of 'lexeme'

        Postcondition: returns the symbol table entry for the first
                       (top-down) occurnace of 'lexeme' and the level of the
                       table in which it was found ... with top level being 0.
                       Returns -1 and None if not found.
        '''
        pass
    
    def st_new(self, tname):
        '''Create a new, named empty table on the symbol table stack
        
        Postcondition: new symbol table is added to the stack
                       the table has two fields
                           name field contains parameter tname
                           tab field contains an empty OrderedDict 
                               for STEntry instances
        '''
        pass
        
    def st_install(self, ste):
        '''Place symbol table entry in table at top of stack

        Precondition: Assumes a table has been created
                      ste is a filled-in symbol table entry.
        Postcondition: ste is added to top symbol table in stack
                       If a ste with the same lexeme already exists, it
                       is replaced.
                       If no table exists on stack, IndexError is raised.
        '''
        pass
    
    def st_replace(self, ste):
        '''Replace the topmost matching symbol table entry

        Preconditions: ste has a lexeme field value assigned
        Postcondition: replaces the top-most symbol table entry
                       with a matching lexeme.  If none is found,
                       silently does nothing and returns.
        '''
        pass
        
    def __str__(self):
        '''Return a string representation of the symbol table stack
        '''
        pass
        
if __name__ == "__main__":

    # Set up symbol table(s)
    symtab = STSt()

    print("New table 'main'")
    symtab.st_new('main')
    for lexeme in ['one', 'two', 'three', 'zeta']:
        symtab.st_install(STEntry(lexeme, 'ID', 0))
        print("Installing:", lexeme)
    
    print("New table 'p1'")
    symtab.st_new('p1')
    for lexeme in ['alpha', 'two', 'beta', 'gamma']:
        symtab.st_install(STEntry(lexeme, 'ID', 0))
        print("Installing:", lexeme)
    
    print("New table 'p2'")
    symtab.st_new('p2')
    for lexeme in ['iota', 'three', 'eta', 'gamma']:
        symtab.st_install(STEntry(lexeme, 'ID', 0))
        print("Installing:", lexeme)
    
    for lexeme in ['one', 'two', 'three', 'alpha', 'fred']:
        print("looking for:", lexeme)
        level, entry = symtab.st_find(lexeme)
        print("level = {:d};  entry = {}".format(level, str(entry)))
        if entry:
            symtab.st_replace(STEntry(entry.lexeme, entry.tokval, 6))
    

    print("\n", symtab)
    while(symtab):
        symtab.pop()
        print("\nAfter pop")
        print("\n", symtab)
    
    # this is the output that is generated by the unit test code
    output = '''
    New table 'main'
    Installing: one
    Installing: two
    Installing: three
    Installing: zeta
    New table 'p1'
    Installing: alpha
    Installing: two
    Installing: beta
    Installing: gamma
    New table 'p2'
    Installing: iota
    Installing: three
    Installing: eta
    Installing: gamma
    looking for: one
    level = 2;  entry = STEntry(lexeme='one', tokval='ID', loc=0)
    looking for: two
    level = 1;  entry = STEntry(lexeme='two', tokval='ID', loc=0)
    looking for: three
    level = 0;  entry = STEntry(lexeme='three', tokval='ID', loc=0)
    looking for: alpha
    level = 1;  entry = STEntry(lexeme='alpha', tokval='ID', loc=0)
    looking for: fred
    level = -1;  entry = None

    Current Symbol Table: 
    p2
            STEntry(lexeme='iota', tokval='ID', loc=0)
            STEntry(lexeme='three', tokval='ID', loc=6)
            STEntry(lexeme='eta', tokval='ID', loc=0)
            STEntry(lexeme='gamma', tokval='ID', loc=0)
    p1
            STEntry(lexeme='alpha', tokval='ID', loc=6)
            STEntry(lexeme='two', tokval='ID', loc=6)
            STEntry(lexeme='beta', tokval='ID', loc=0)
            STEntry(lexeme='gamma', tokval='ID', loc=0)
    main
            STEntry(lexeme='one', tokval='ID', loc=6)
            STEntry(lexeme='two', tokval='ID', loc=0)
            STEntry(lexeme='three', tokval='ID', loc=0)
            STEntry(lexeme='zeta', tokval='ID', loc=0)

    After pop

    Current Symbol Table: 
    p1
            STEntry(lexeme='alpha', tokval='ID', loc=6)
            STEntry(lexeme='two', tokval='ID', loc=6)
            STEntry(lexeme='beta', tokval='ID', loc=0)
            STEntry(lexeme='gamma', tokval='ID', loc=0)
    main
            STEntry(lexeme='one', tokval='ID', loc=6)
            STEntry(lexeme='two', tokval='ID', loc=0)
            STEntry(lexeme='three', tokval='ID', loc=0)
            STEntry(lexeme='zeta', tokval='ID', loc=0)

    After pop

    Current Symbol Table: 
    main
            STEntry(lexeme='one', tokval='ID', loc=6)
            STEntry(lexeme='two', tokval='ID', loc=0)
            STEntry(lexeme='three', tokval='ID', loc=0)
            STEntry(lexeme='zeta', tokval='ID', loc=0)
            
    
    After pop

     Current Symbol Table:'''        